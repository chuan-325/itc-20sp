# Chapter 1: 正则语言

## 1.1 有穷自动机

### 初识有穷自动机

#### 定义 (有穷自动机)

有穷自动机 (FSM/FA/DFA) 由有穷个状态组成. 它是一种简单且便于处理问题和计算的计算模型. 通常用状态图来表示 (也可以等价地用状态转移表表示) .

状态 (转移) 图的要素: (1) 状态, (2) 转移.

- 状态: 一般是一个圈里一个字母 (_带下标_) 标识.

  - 特殊状态: 初始状态,接受状态 (以双圈表示).
  - 接受状态: 接受输入的字符串.

- 转移: 箭头, 箭头线上标明了输入符号.

"自动机在某个字符串上运行" : 输入带, 只读头, 状态控制器.

> e.g. 单向只读输入带, 单向只读头, 有穷状态控制器.

#### 定义 (确定型有穷自动机 (DFA) 的形式化定义)

_确定性有穷状态机_ (DFA) 是一个五元组

$$M=(Q,\Sigma,\delta,q_0,F)$$

其中,

- $Q$ 是一个有穷集合, 称为 _状态集_ ;
- $\Sigma$ 是一个有穷集合, 称为 _字母表_ ;
- $\delta: Q\times\Sigma\mapsto Q$ 是 _转移函数_ (可以以列表等形式表示) ;
- $q_0\in Q$ 是 _起始状态_ ;
- $F\subseteq Q$ 是 _接受状态集_, 也称 _终结状态_ .

#### 定义 (DFA 计算的形式化定义)

设 $M=(Q,\Sigma,\delta,q_0,F)$ 是一个自动机, $w=a_1a_2\cdots a_n$ 是 $\Sigma$ 上的一个字符串, 如果存在 $Q$ 中的状态序列 $s_1,s_2,\cdots ,s_n$, 使得下列条件满足:

- $s_0=q_0,$
- 对于任意 $i\in\{0,1,2\cdots,n-1\}$, $\delta(s_i,a_i)=s_{i+1},$
- $s_n\in F,$

则称 $M$ 接受字符串 $w.$

**机器的语言**: 机器 $M$ 所接受的*全部*字符串的集合是机器 $M$ 的语言, 记为 $L(M):=\{w\in\Sigma^* | \delta(q_0,w)\in F\}.$ 为了区别起见, 一般采用 "$M$ _识别_ 语言 $L(M)$" 的提法

> 注意:
>
> - 区别机器 "接受字符串" 与 "接受语言" .
> - 计算 $L(M)$ 时不要漏掉空串.

有时, 将 $\delta(q_i,a)=q_j$ 写成 $q_i\xrightarrow{a}q_j$ , 这样, 上述形式化定义的第二条可以写作:

$$
s_0\xrightarrow{a_0}s_1\xrightarrow{a_1}s_2\xrightarrow{a_2}s_3\cdots s_{n-1}\xrightarrow{a_{n-1}}s_n.
$$

### 正则语言及其运算

#### 定义 (正则语言)

正则语言: 若一个语言可被一台 DFA 所接受, 则称它是正则语言.

> 任何一个 DFA 接受的语言都是正则语言;
>
> 对于任何一个正则语言 A, 必然存在一个 DFA M, 使得 A=$L(M)$.

#### 定义 (正则语言的正则运算)

见[绪论中的说明部分](chap_00.md#_6). <!--语言的运算-->

#### 定义 (正则语言的封闭性)

- 如果任意两个语言的交仍然是一个正则语言, 则称正则语言关于交运算封闭;
- 如果任意一个正则语言的补语言也是正则语言, 则称正则语言关于补运算封闭;
- 类似地, 可定义正则语言关于并运算/ 连接运算及星运算的封闭性.

> Lecture 02: 非确定型有限状态自动机 (2020-02-28)
>
> 内容提要: 正则语言运算的封闭性, NFA 的概念, NFA 和 DFA 的等价性, NFA 和 DFA 的相互转化.

#### 定理 (正则语言的封闭性)

**(定理 1.12) 正则语言类在并运算下是封闭的.**

_证明 (思路) :_

- 对于任意的两个正则语言 $A_1,A_2$, 构造一个 DFA $M$, 使得 $L(M)=A_1\cup A_2$.
- 从接受正则语言 $A_1,A_2$ 的 DFA $M_1,M_2$, 定义一个新的 DFA. 利用多元组这一形式化的数学工具.
- 证明 $L(M)=L(M_1)\cup L(M_2)$.
  - 按照证明集合相等的常规思路, 分别证明两边互相 $\subseteq$ 另一边.

**(定理 1.13) 正则语言类在连接运算下封闭.**

_证明 (思路) :_

- 模仿上一段的构造性证明, 我们想到基于任意的有穷自动机 $M_1,M_2$, 造出一台有穷自动机 $M$, 它识别的语言中的所有字符串都满足: $M_1$接受 "第一段" 字符串, $M_2$接受 "第二段" 字符串, 即 $L(M)=L(M_1)\circ L(M_2)$.
- 如何将输入分开?
  - 引入非确定性.

## 1.2 非确定型有限状态自动机 (NFA)

### 非确定性

#### DFA 与 NFA 的区别

- 非确定性: NFA 的状态转移存在 "一对多"
  - NFA 中, 一个状态对于字母表中的每一个符号可能有 $0$ 个/ $1$ 个/ 多个射出的箭头, 在 DFA 中则是恰好一个;
- $\epsilon$ 迁移: $\epsilon$ 不消耗计算符号.
  - NFA 中的箭头上可以标记字母表中的符号或$\epsilon$, 在 DFA 中则没有$\epsilon$.

#### 定义 (NFA 的计算)

对于一个字符串, 在一个 NFA 下可能同时存在成功的计算和不成功的计算.

规定: 只要某个 NFA 对一个字符串 _存在_ 一次能成功的计算, 则这个字符串就被这个 NFA 所接受.

> Nondeterminism creates many transition paths, but if there is one path leading to an accepting state, then the input is.

一个 NFA $M$ 所接受的语言: 该 NFA $M$ 所接受的字符串的集合, 记作$L(M)$.

> 若两个自动机接受的语言相同, 则这两个自动机等价.

#### 定义 (非确定型有穷自动机 (NFA) 的形式化定义)

一个**非确定型有穷自动机**是一个五元组

$$M=(Q,\Sigma,\delta,q_0,F)$$

其中,

- $Q$ 是一个有限集合, 称为 _状态集_ ;
- $\Sigma$ 是一个有限非空集, 称为 _字母表_ ;
- $\delta:Q\times\Sigma_{\epsilon}\mapsto2^Q$ 是一个从$Q\times\Sigma_{\epsilon}$ 到 $2^Q$ 的函数, 这里 $\Sigma_{\epsilon}=\Sigma\cup\{\epsilon\}$, $2^Q$ 是指 $Q$ 的幂集;
- $q_0\in Q$ 是 _起始状态_ ;
- $F\subseteq Q$ 是 _接受状态集_ .

#### 定义 (NFA 计算的形式化定义)

> 设 $w$ 是 $\Sigma$ 上的一个字符串, *规定*在 $w$ 中增加有穷个 $\epsilon$ 后所得到的字符序列 $y_0y_1\cdots y_n$ (这里每个 $y_i\in\Sigma_{\epsilon}$) 与 $w$ 相等.
>
> 例如: $10110=\epsilon\epsilon10\epsilon110\epsilon$.

设 $M=(Q,\Sigma,\delta,q_0,F)$ 是一个 NFA, $w$ 是字母表 $\Sigma$ 上的一个字符串, 如果能把 $w$ 写成 $w=y_0y_1\cdots y_{n-1}$ (这里每个$y_i\in\Sigma_{\epsilon}$) , 并且存在 $Q$ 中的状态序列 $s_0,s_1,s_2,\cdots,s_n$ 使得下列条件满足:

- $s_0=q_0$;
- $\forall i\in\{0,1,2,\cdots,n-1\},s_{i+1}\in\delta(s_i,y_i)$;
- $s_n\in F$.

则称 $M$ 接受 $w$.

记号: 称 $L(M)=\{w|w\in\Sigma^*,\text{ 且 M 接受 }w\}$ 是 $M$ 识别的语言.

### NFA 与 DFA 的等价性

比较 NFA 与 DFA 各自的特点, 就接受字符串的能力而言, NFA 与 DFA 的表达能力一样强.

**(定理 1.19) 每一台非确定型有穷自动机都等价于一台确定型有穷自动机.**

_证明 (思路) :_

- 设一个语言被一台 NFA 识别, 那么必须证明还有一台 DFA 能识别这个语言. 因此要设法把 NFA 转化为能够模拟它的 DFA.

取一台 NFA $N=(Q,\Sigma,\delta,q_0,F)$, 构造 DFA $M=\{Q^{\prime},\Sigma,\delta^{\prime},E(\{q_0\}),F^{\prime}\}$, 思路如下:

- $Q^{\prime}=\mathcal{P}(Q)$
  - 考虑 NFA 的状态集 $Q$, 从[NFA 的定义](#nfa_1)<!--#定义非确定型有穷自动机nfa的形式化定义-->出发, 让 $Q$ 的幂集 $2^Q$ 成为 DFA 的状态集
  - 不要忘了空集 $\emptyset$
- $E(\{q_0\})$
  - $E(R):=\{q|\text{从}R\text{ 出发, 沿着0个或多个 }\epsilon\text{ 箭头可以到达 }q\},R\subseteq Q$
  - 注意: 转化过后的集合是一个状态 (看定义! )
- $\delta^{\prime}(R,a)=\left\{q\in Q|\exists r\in R,s.t.q\in E(\delta(r,a))\right\},\forall R\in Q,a\in\Sigma.$
- $F^{\prime}=\{R\in Q^{\prime}|R\text{ 包含 }N\text{ 的一个接受状态}\}$
  - 所有包含 $F$ 中状态的集合均在新的接受状态集里

> 手动把一个 DFA 转化成 NFA 的时候推荐这样做:
>
> 1. 获取新的状态集;
> 2. 确定新的起始状态和接受状态集;
> 3. 计算新的转移函数;
> 4. 去掉新的 DFA 中不需要的状态.

**(推论 1.20) 一个语言是正则的, 当且仅当有一台 NFA 能识别这个语言.**

> Lecture 03: 正则语言的封闭性, 正则表达式 (2020-03-03)
>
> 内容提要: 正则语言关于并/ 交/ 补/ 连接/ 星运算的封闭性, 正则表达式, 到正则表达式到 NFA 的转换.

### 正则语言类在正则运算下的封闭性

正则语言的运算: 并/ 交/ 补/ 连接 (concatenation)/ 星号运算 (\*) .

**(定理 1.20) 正则语言类在并, 交, 补, 连接及星号运算下封闭.**

_证明 (思路) :_

- 利用 DFA 可给出关于 _并_/ _交_/ _补_ 运算的证明;
- 利用 NFA 可给出关于 _并_/ _连接_/ _星_ 运算的证明.

将证明分割为三个引理的证明:

**(定理 1.22) 正则语言类在并运算下封闭.**

_证明 (思路) :_

对于任意两个正则语言, 要证明它们的并是正则的, 则会想到取识别它们的 NFA 来构造新的 NFA, 使之能够识别这个并.

**(定理 1.23) 正则语言类在连接运算下封闭.**

_证明 (思路) :_

对于任意两个正则语言, 要证明它们的连接是正则的, 则会想到取识别它们的 NFA 来构造新的 NFA, 使之能够识别这个连接.

**(定理 1.24) 正则语言类在星号运算下封闭.**

_证明 (思路) :_

利用能够识别正则语言$A$的 NFA, 构造新的 NFA 使之能够识别$A^*$.

> **关于构造**
>
> 不太好的想法:
>
> - 把起始状态直接加入接受状态集中;
> - 这可能导致加进一些其他不想要的字符串;
>
> 更好的想法:
>
> - 添加一个新的起始状态, 同时也是接受状态, 并且有一个指向原起始状态的 $\epsilon$ 箭头.
> - 这个方案可以做到 "在识别的语言中加入 $\epsilon$ 而不加入其他任何字符串" , 这也是我们构造性证明的关键.

## 1.3 正则表达式

#### 定义 (正则表达式)

> DFA 和 NFA 都是正则语言的表达方式, *正则表达式*则是正则语言的另一种表达方式.

设 $\Sigma$ 是一个字母表, $\Sigma$ 上的 **正则表达式** 定义如下:

(注意: 后两条是 _递归定义_ )

- $\epsilon$ 是 $\Sigma$ 上的 _正则表达式_ ;
- $\emptyset$ 是 $\Sigma$ 上的 _正则表达式_ ;
- 如果 $a\in\Sigma$, 则 $a$ 是 $\Sigma$ 上的 _正则表达式_ ;
- 如果 $R_1$ 和 $R_2$ 是 $\Sigma$ 上的 _正则表达式_ , 那么 $(R_1\cup R_2)$ 和 $(R_1\circ R_2)$ 也是 $\Sigma$ 上的 _正则表达式_ ;
- 如果 $R$ 是 $\Sigma$ 上的 _正则表达式_ , 则 $(R^∗)$ 也是$\Sigma$上的 _正则表达式_ .

其中, $\cup,\circ,*$ 分别称为**并**运算符/ **连接**运算符/ **星号**运算符.

> 关于运算符的几点说明:
>
> 1. 在不混淆的情况下, 有些括弧可以省略;
> 2. 运算优先级: 无括弧时, $*$ 优先于 $\circ$, $\circ$ 优先于 $\cup$;
> 3. 连接运算符号$\circ$可省略, 如 $R^{+}=R\circ(R^{∗})=RR^{∗}$.

> 显然地, 正则表达式关于并/ 连接/ 星号运算是封闭的.

一个字母表上的任意一个正则表达式 $R$ 都表示了该字母表上的一个语言 (_字符串的集合_) . 此外, 正则表达式的 _递归定义方式_ 暗示我们, 它是由 _有穷个_ 符号的运算得到的.

后面我们还将证明正则表达式表示的语言都是正则语言.

> 注意正则表达式带有$\cup,\circ$的运算:
>
> 1. 将空语言加到任一语言上不会改变这个语言, 将空串加到任一字符串上不会改变这个字符串, 所以有**恒等式**: $R\cup\emptyset=R， R\circ\epsilon=R,$
> 2. 但若将两个符号换位, 则新的式子未必成立. 比如说, 有的语言中可能没有空串 $\epsilon$ , 并且所有语言跟空语言 $\emptyset$ 连接都会得到空语言 $\emptyset$ .

> 在[正则表达式到 NFA 的转换](#nfa_3)<!--#正则表达式到nfa的转换-->的一个证明中提到过正则表达式的定义.

#### 定义 (正则表达式表示的语言)

正则表达式 $R$ 表示的 **语言** $L(R)$ 递归定义如下:

- $L(\epsilon)=\{\epsilon\}$;
- $L(\emptyset)=\emptyset$;
- 对于 $a\in\Sigma,L(a)=\{a\}$;
- $L(R_1\cup R_2)=L(R_1)\cup L(R_2)$;
- $L(R_1\circ R_2)=L(R_1)\circ L(R_2)$;
- $L(R^{\text{*}})=(L(R))^{\text{*}}$.

> 正则表达式 $R$, 常常与它表示的语言混用, 不加区分. 比如 $1\circ(0\cup 1)=\{10,11\}$. 但当想要明显地区分正则表达式 $R$和它所表示的语言时, 把 $R$表示的语言写成 $L(R)$.

> 不要混淆正则表达式 $\epsilon$ 和 $\emptyset$,表达式 $\epsilon$表示只含空串的语言 ($\epsilon$ 里面还是有 "空串" 这一个东西的, 而 $\emptyset$ 就真的一滴都不剩啦) .

#### 正则表达式到 NFA 的转换

**(定理) 设 $R$ 是 $\Sigma$ 上的任意一个正则表达式, 则存在 $\Sigma$ 上的一个 NFA $N_R$, 使得 $L(R)=L(N_R)$.**

_证明 (思路) :_

归纳证明, 对[正则表达式的定义](#_10)<!--#定义正则表达式-->中的每一条构造对应的 NFA.

由以上的定理可以得到:

**(引理 1.29) 如果一个语言可以用正则表达式描述, 那么它是正则语言.**

i.e 正则表达式表达的语言 $\subseteq$ 正则语言.

_证明 (思路) :_

构造变换 "RE to NFA" .

假设正则表达式 $R$ 描述某语言 $A$. 要证明该语言是正则的, 则需要构造一台能够识别该语言的 NFA, 即 "将正则表达式 $R$ 转换成一台识别语言 $A$ 的 NFA" .

- $R=a,R=\epsilon,R=\emptyset$ 的情况下, 均能举出非常简单的 NFA 作为构造;
- $R=R_1\cup R_2,R=R_1\circ R_2,R=R_1^*$ 的情况下, 使用正则语言类在正则运算下封闭的证明中所给出的构造 (即用识别 $R_1,R_2$ 的 NFA 构造出关于 $R$ 的 NFA) .

**注意**: 并/ 连接/ 星号三种运算所对应的 "RE to NFA" 变换方式的细节. 比如, 并运算使用两个 $\epsilon$ 实现了分路, 连接运算中约定地引入了 $\epsilon$ 迁移, 星号运算常常会把循环中的首个状态分成 **"接收状态 ×1+ $\epsilon$ 迁移 ×1"** 的形式.

> Lecture 04: 正则表达式 (续)/ 非正则语言 (2020-03-06)
>
> 内容提要: NFA 到正则表达式的转换, 非正则语言 (非正则语言的泵引理)

**(引理 1.32) 如果一个语言是正则语言, 那么可以用正则表达式来描述它.**

_证明 (思路) :_

构造变换 "NFA to RE" .

> 要将 NFA 转换成等价的正则表达式, 可以从简单的情况开始考虑:
>
> - 简单的连续状态 $\leftrightarrow$ NFA 的连接
> - 循环结构 $\leftrightarrow$ NFA 的星号运算
> - 双路结构 $\leftrightarrow$ NFA 的并运算

- **Step 1**
  对 M 增加新的初始状态 $q_{\text{start}}$ 和新的接受状态 $q_{\text{accept}}$ ,添加从 $q_{\text{start}}$ 到原初始状态, 和从原接受状态到 $q_{\text{accept}}$ 的 $\epsilon$ 迁移, 并使 $q_{\text{accept}}$ 成为新 NFA 的唯一接受状态.
- **Step 2**
  合并自动机中出发状态和到达状态都相同的迁移, 使得除 $q_{\text{start}}$ 和 $q_{\text{accept}}$ 之外, 从一个状态到自身和到另外的状态有且只能有一条迁移.
- **Step 3**
  使用前面在引用区讨论过的那种思路 (使用并运算等) 逐步删掉除 $q_{\text{start}}$ 和 $q_{\text{accept}}$ 之外的所有结点, 剩下的唯一一条从 $q_{\text{start}}$ 到 $q_{\text{accept}}$ 的迁移上标注的正则表达式就是所要的结果.

结合 _引理 1.29_ 与 _引理 1.32_ , 可以得到

**(定理 1.28) 一个语言是正则的, 当且仅当可以用正则表达式来描述它.**

在刚刚 _引理 1.32_ 的证明中, 出现了一类新的自动机: **广义非确定型自动机**.

#### 定义 (广义非确定型有穷自动机 (GNFA) 的形式化定义)

一个 **GNFA** 是一个五元组 $M=(Q,\Sigma,\delta,q_{\text{start}},q_{\text{accept}})$ , 其中,

- $Q$ 是一个有限集合, 称为 _状态集_ ;
- $\Sigma$ 是一个有限非空集, 称为 _字母表_ ;
- $\delta:(Q\backslash\{q_{\text{accept}}\})\times(Q\backslash\{q_{\text{start}}\})\mapsto RE(\Sigma)$ 是迁移函数, 这里的 $RE(\Sigma)$ 表示 $\Sigma$ 上所有正则表达式的集合;
  - 这个迁移函数和之前略有不同, 表示的是某一正则表达式对应两个状态之间的跳转进程;
  - $Q$ 中去掉起始状态/接受状态的操作, 其实就是对 GNFA 定义的重申, 强调了自动机接受字符串后的运行顺序;
- $q_{\text{start}}\in Q$ 是 _起始状态_ ;
- $q_{\text{accept}}\in Q$ 是 _接受状态_ .

#### 定义 (GNFA 计算的形式化定义)

> 设 $w$ 是 $\Sigma$ 上的一个字符串, _规定_ 在 $w$ 中增加有穷个 $\epsilon$ 后所得到的字符序列 $y_0y_1\cdots y_n$ (这里每个 $y_i\in\Sigma_{\epsilon}$ ) 与 $w$ 相等.
> 例如: $10110=\epsilon\epsilon10\epsilon110\epsilon$.

设 $M=(Q,\Sigma,\delta,q_{\text{start}},q_{\text{accept}})$ 是一个 GNFA, $w\in\Sigma^*$, 如果能把$w$写成$w=w_0w_1\cdots w_{n-1}$ (这里每个$y_i\in\Sigma_{\epsilon}$) , 并且存在 $Q$ 中的状态序列 $s_0,s_1,s_2,\cdots,s_n$ 使得下列条件满足:

- $s_0=q_{\text{start}}$;
- 对于任意 $i\in\{0,1,2,\cdots,n-1\},w_i\in L(\delta(s_i,s_{i+1}))$;
- $s_n=q_{\text{accept}}$.

则称 $M$ 接受 $w$.

> 基于 DFA (或者 NFA) 的 GNFA 构造过程, 就是在做题的时候喜闻乐见的 "to RE" 过程.

到这里, 我们可以得出这样的结论: **正则语言 = DFA 接受的语言 = NFA 接受的语言 = 正则表达式表示的语言** .

## 1.4 非正则语言

#### 定理 (正则语言的泵引理)

(**泵引理**) 对于任意的 (无穷) 正则语言 $A$, 存在正整数 $p$ ($p$ 称为泵长度) ,使得对于任意 $w\in A$, 如果 $|w|\geq p$, 则 $w$ 可被分成 $3$ 段, 即 $w=xyz$, 且

- $|y|\geq 1$;
- $|xy|\leq p$;
- 对于任意 $n\geq0$, $xy^nz\in A$.

_证明 (思路) :_ 证明应用了鸽笼原理.

(应用定理) 由于 $A$ 是正则语言, 故存在一个 DFA $M=(Q,\Sigma,\delta,q_0,F)$, 使得 $A=L(M)$. 取 $p=|Q|$, 则 $p\in\mathbb{N}^+$.

(应用定义) 设 $w\in A$ 且 $|w|\geq p$, 令 $w=a_1a_2\cdots a_{m-1}$, 于是存在 $Q$ 中的状态序列 $s_0,s_1,s_2,\cdots,s_m$ 使得

1. $s_0=q_0$,
2. 对于任意 $i\in\{0,1,2,\cdots,m-1\},\delta(s_i,a_i)=s_{i+1}$,
3. $s_m\in F$.

状态序列 $s_0,s_1,s_2,\cdots,s_m$ 的长度为 $m+1=|w|+1\geq p+1$, 而 $s_0,s_1,s_2,\cdots,s_m$ 全部都在 $Q$ 中, 且 $Q$ 中所有状态的总个数为 $p$.

由鸽笼原理可知, 在序列 $s_0,s_1,s_2,\cdots,s_p$ 之中, 必然存在 $s_i=s_j,i\neq j,1\leq i,j\leq p$.

于是, 在 $M$ 接受 $w$ 的计算路径中必然出现一个环 (即 $s_i$ 与 $s_j$ 之间的过程) .

> 泵引理给出的是某种语言正则的**必要条件**. (不是充分!)

## 本章小结

- 主要概念 (是如何定义的? )
  - 正则语言, DFA, NFA, 正则表达式.
- 主要结论 (是如何证明的? )
  - 正则语言类 = DFA 接受的语言类 = NFA 接受的语言类 = 正则表达式表示的语言类
- 主要转换算法
  - NFA to DFA, RE to NFA, NFA to RE
- 正则语言关于并/ 交/ 补/ 连接及星号运算的封闭性
  - 用 DFA 构造正则语言的并/ 交/ 补运算
  - 用 NFA 构造正则语言的并/ 连接/ 星号运算
- 归纳定义和归纳证明的方法
  - 如 RE 的定义/ RE 表示的语言/ 以及 RE to NFA 的转换过程
- 泵引理及简单应用 (证明非正则性)
